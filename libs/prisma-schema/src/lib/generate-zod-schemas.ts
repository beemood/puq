import type { DMMF } from '@prisma/client/runtime/library.js';

/**
 * Check the field is included in create-operation
 * @param field
 * @returns
 */
export function isCreteField(field: DMMF.Field) {
  if (isGenerated(field)) {
    return false;
  }
  if (field.relationName) {
    return false;
  }
  return true;
}

/**
 * Check the field is allowed to update
 * @param field
 * @returns
 */
export function isUpdateField(field: DMMF.Field) {
  if (isGenerated(field)) {
    return false;
  }

  if (field.documentation?.includes('@readonly')) {
    return false;
  }

  if (field.relationName) {
    return false;
  }

  return true;
}

/**
 * Check the field is suppoed to be hashed
 * @param field
 * @returns
 */
export function isHahsed(field: DMMF.Field) {
  return field.documentation?.includes('hash');
}

/**
 * Check the field is supposed to be encripted
 * @param field
 * @returns
 */
export function isEncripted(field: DMMF.Field) {
  return field.documentation?.includes('encrypt');
}

/**
 * Check the field is generated by the database such as timestamp field (createdAt, updatedAt), generated uuid, or id
 * @param field
 * @returns
 */
export function isGenerated(field: DMMF.Field) {
  if (field.kind === 'unsupported') {
    return true;
  }

  if (field.documentation?.includes('@generated')) {
    return true;
  }

  if (field.default) {
    if ((field.default as DMMF.FieldDefault).name) {
      return true;
    }
  }

  if (field.isUpdatedAt) {
    return true;
  }

  return false;
}

/**
 * Pick the scalar where schema such as IntFilterSchema, NumberFilterSchema, DateTimeFilterSchema
 */
export function pickSchalarWhereSchema(field: DMMF.Field) {
  switch (field.kind) {
    case 'object': {
      if (field.isList) {
        return `z.object({ 
          some: ${field.type}OwnWhereSchema,
          every: ${field.type}OwnWhereSchema,
          none: ${field.type}OwnWhereSchema,
          }).partial()`;
      } else {
        return `${field.type}OwnWhereSchema`;
      }
    }
    case 'scalar': {
      switch (field.type) {
        case 'String': {
          return 'z.string().or(PZ.StringFilterSchema)';
        }
        case 'Float':
        case 'Decimal': {
          return 'z.coerce.number().or(PZ.NumberFilterSchema)';
        }
        case 'Int': {
          return 'z.coerce.number().int().or(PZ.IntegerFilterSchema)';
        }
        case 'Boolean': {
          return 'z.coerce.boolean().or(PZ.BooleanFilterSchema)';
        }
        case 'Date':
        case 'DateTime': {
          return 'z.string().or(PZ.DateTimeFilterSchema)';
        }
      }
      return '{}';
    }
    case 'enum': {
      return `${field.type}Schema`;
    }
    case 'unsupported': {
      return '';
    }
  }
}

export function generateSlugExtension(model: DMMF.Model) {
  if (model.fields.find((e) => e.name === 'slug')) {
    const sluggingFieldName = model.fields.find((e) => {
      if (!e.relationName) {
        return e.name === 'name' || e.name === 'title';
      }
      return false;
    })?.name;

    if (sluggingFieldName) {
      return `.transform(slugTransformer("${sluggingFieldName}"))`;
    }
  }

  return '';
}

export function generateZodSchemas(datamodel: DMMF.Datamodel) {
  const importList: string[] = [
    '/* eslint-disable @typescript-eslint/no-explicit-any */',
    `import * as PZ from '@puq/zod';`,
    `import { z } from 'zod';`,
    `import { slugify } from '@puq/names';`,
  ];
  const firstResult: string[] = [];
  const secondResult: string[] = [];
  const thirdResult: string[] = [];

  const result: string[] = [];
  const postResult: string[] = [];

  function toZodPropertyDefinition(field: DMMF.Field) {
    const pt = [];

    switch (field.kind) {
      case 'object': {
        if (field.type === 'Json') {
          pt.push('z.json()');
        }
        break;
      }
      case 'scalar': {
        switch (field.type) {
          case 'String': {
            // Specific stirng schemas  by property name
            if (field.name === 'name') {
              pt.push('nameSchema.clone()');
            } else if (field.name === 'description') {
              pt.push('descriptionSchema.clone()');
            } else if (field.name === 'email') {
              pt.push('emailSchema.clone()');
            } else if (field.name === 'slug') {
              pt.push('slugSchema.clone()');
            } else {
              pt.push('z.string()');
            }
            break;
          }
          case 'Boolean': {
            pt.push('z.boolean()');
            break;
          }
          case 'Float':
          case 'Decimal': {
            if (
              field.name === 'price' ||
              field.name === 'cost' ||
              field.name === 'total' ||
              field.name === 'subtotal' ||
              field.name === 'taxtotal'
            ) {
              pt.push('currencySchema.clone()');
            } else {
              pt.push('z.coerce.number()');
            }

            break;
          }

          case 'Int': {
            if (
              field.name === 'id' ||
              field.name === 'quantity' ||
              field.name === 'age'
            ) {
              pt.push('positiveIntegerSchema.clone()');
            } else {
              pt.push('z.coerce.number().int()');
            }
            break;
          }

          case 'DateTime': {
            pt.push('dateSchema.clone()');

            break;
          }

          default: {
            throw new Error(field.type + ' is not defiend here!');
          }
        }

        break;
      }
      case 'enum': {
        pt.push(field.type + 'Schema');
        break;
      }
      case 'unsupported': {
        break;
      }
    }

    if (field.name.startsWith('slug')) {
      pt.push('optional()');
    } else if (!field.isRequired || field.hasDefaultValue) {
      pt.push('optional()');
    }

    return `${field.name}:${pt.join('.')}`;
  }

  // Create all enum schemas upfront
  for (const en of datamodel.enums) {
    const enumFields = en.values.map((e) => `"${e.name}"`).join(',');
    const enumDefinition = `export const ${en.name}Schema = z.enum([${enumFields}])`;
    firstResult.push(enumDefinition);
  }

  // Itereate through each model and create schemas
  for (const model of datamodel.models) {
    const createFields: DMMF.Field[] = [];
    const updateFields: DMMF.Field[] = [];
    const orderFields: DMMF.Field[] = [];
    const whereFields: DMMF.Field[] = [];
    const selectFields: DMMF.Field[] = [];
    const relationFields: DMMF.Field[] = [];
    const distinctFields: DMMF.Field[] = [];

    for (const field of model.fields) {
      selectFields.push(field);
      whereFields.push(field);
      if (isCreteField(field)) {
        createFields.push(field);
      }

      if (isUpdateField(field)) {
        updateFields.push(field);
      }

      if (field.relationName) {
        relationFields.push(field);
      }
      if (!field.relationName) {
        distinctFields.push(field);
      }

      if (field.kind === 'scalar') {
        orderFields.push(field);
      }
    }

    const createSchemaFields = createFields
      .map(toZodPropertyDefinition)
      .join(',\n');

    const slugTransformer = generateSlugExtension(model);

    if (slugTransformer) {
      const slugifyImport = `import { slugify } from '@puq/names';`;
      if (!importList.includes(slugifyImport)) {
        importList.push(slugifyImport);
      }
    }

    const createSchema = `
    export const ${model.name}CreateSchema = z.object({ 
      ${createSchemaFields}
    })${slugTransformer}
    `;

    const updateSchema = `
    export const ${model.name}UpdateSchema = z.object({ 
        ${updateFields
          .map(toZodPropertyDefinition)
          .map((e) => e + '.optional()')
          .join(',\n')}
    })${slugTransformer}
    `;

    const distinctFieldsString = distinctFields
      .map((e) => `"${e.name}"`)
      .join(',');
    const distinctFieldsSchema = `
    export const ${model.name}DistinctFieldsSchema = z.enum([ ${distinctFieldsString} ]).array()
    `;

    const orderBySchemaFields = orderFields
      .map((e) => `${e.name}: PZ.OrderDirectionSchema`)
      .join(',\n');
    const orderBySchema = `
    export const ${model.name}OrderBySchema = z.object({
        ${orderBySchemaFields}
    }).partial()

    export const ${model.name}OrderBySchemaJson = z.preprocess(jsonParser, ${model.name}OrderBySchema);
    `;

    const ownSelectFieldsFields = selectFields
      .map((e) => `${e.name}: z.boolean()`)
      .join(',\n');
    const ownSelectFieldsSchema = `
      export const ${model.name}OwnSelectFieldsSchema = z.object({ 
          ${ownSelectFieldsFields}
      }).partial()
      
      export const ${model.name}OwnSelectFieldsSchemaJson = z.preprocess(jsonParser, ${model.name}OwnSelectFieldsSchema);
      `;

    const ownWhereSchemaFields = whereFields
      .filter((e) => !e.relationName)
      .map((e) => `${e.name}:${pickSchalarWhereSchema(e)}`)
      .join(',\n');
    const ownWhereSchema = `
    export const ${model.name}OwnWhereSchema = z.object({ 
      ${ownWhereSchemaFields}
    }).partial()

    export const ${model.name}OwnWhereSchemaJson = z.preprocess(jsonParser, ${model.name}OwnWhereSchema);
    `;

    const ownQuerySchema = `
    export const ${model.name}OwnQuerySchema = z.object({ 
      where: ${model.name}OwnWhereSchemaJson, 
      distinct: ${model.name}DistinctFieldsSchema 
    }).partial()
    `;

    const ownQueryOneSchema = `
    export const ${model.name}OwnQueryOneSchema = z.object({ 
        where:${model.name}OwnWhereSchemaJson,
        distinct: ${model.name}DistinctFieldsSchema
    }).partial()
    `;

    const whereSchemaFields = whereFields
      .map((e) => `${e.name}: ${pickSchalarWhereSchema(e)}`)
      .join(',\n');
    const whereSchema = `
    export const ${model.name}WhereSchema = z.object({ 
        ${whereSchemaFields}
    }).partial()

    export const ${model.name}WhereSchemaJson = z.preprocess(jsonParser, ${model.name}WhereSchema);
    `;

    const ownIncludeSchemaFields = relationFields
      .map((e) => {
        return `${e.name}: z.boolean()`;
      })
      .join(',\n');
    const ownIncludeSchema = `
    export const ${model.name}OwnIncludeSchema = z.object({ 
      ${ownIncludeSchemaFields}
    }).partial()

    export const ${model.name}OwnIncludeSchemaJson = z.preprocess(jsonParser, ${model.name}OwnIncludeSchema);
    `;

    const includeSchemaFields = relationFields
      .map((e) => {
        if (e.isList) {
          return `${e.name}: z.boolean().or(${e.type}OwnQuerySchema)`;
        } else {
          return `${e.name}: z.boolean().or(${e.type}OwnQueryOneSchema)`;
        }
      })
      .join(',\n');
    const includeSchema = `
    export const ${model.name}IncludeSchema = z.object({ 
      ${includeSchemaFields}
    }).partial()

    export const ${model.name}IncludeSchemaJson = z.preprocess(jsonParser, ${model.name}IncludeSchema);
    `;

    const queryOneSchema = `
    export const ${model.name}QueryOneSchema = z.object({ 
      where: ${model.name}WhereSchemaJson,
      distinct: ${model.name}DistinctFieldsSchema
    }).partial()
    `;

    const querySchema = `
    export const ${model.name}QuerySchema = z.object({ 
      ...PaginationSchema.shape,
      where: ${model.name}WhereSchemaJson, 
      distinct: ${model.name}DistinctFieldsSchema, 
      orderBy: ${model.name}OrderBySchemaJson,
    }).partial()
    `;

    const selectFieldSchemaFields = selectFields
      .map((e) => {
        if (e.relationName) {
          if (e.isList) {
            return `${e.name}: z.boolean().or(${e.type}OwnQuerySchema)`;
          } else {
            return `${e.name}: z.boolean().or(${e.type}OwnQueryOneSchema)`;
          }
        }
        return `${e.name}: z.boolean()`;
      })
      .join(',\n');

    const selectFieldsSchema = `
    export const ${model.name}SelectFieldsSchema = z.object({ 
          ${selectFieldSchemaFields}
     }).partial()

    export const ${model.name}SelectFieldsSchemaJson = z.preprocess(jsonParser, ${model.name}SelectFieldsSchema);
     `;

    const projectionSchema = `
     export const ${model.name}ProjectionSchema = z.union([
      z
        .object({
          omit: ${model.name}SelectFieldsSchemaJson
        })
        .partial(),
      z
        .object({
          select: ${model.name}SelectFieldsSchemaJson
        })
        .partial(),
      z
        .object({
          include: ${model.name}IncludeSchemaJson,
        })
        .partial(),
      ]).optional();
     
     `;

    firstResult.push(ownSelectFieldsSchema);
    firstResult.push(distinctFieldsSchema);
    secondResult.push(ownWhereSchema);
    thirdResult.push(ownIncludeSchema);
    thirdResult.push(ownQueryOneSchema);
    thirdResult.push(ownQuerySchema);

    result.push(createSchema);
    result.push(updateSchema);
    result.push(orderBySchema);
    result.push(whereSchema);
    // result.push(selectFieldsSchema);
    result.push(selectFieldsSchema);
    result.push(includeSchema);
    result.push(projectionSchema);
    postResult.push(queryOneSchema);
    postResult.push(querySchema);

    const allTypes = `
    export type  ${model.name}Create = z.infer<typeof ${model.name}CreateSchema>;

    export type  ${model.name}Update = z.infer<typeof ${model.name}UpdateSchema>;

    export type  ${model.name}OrderBy = z.infer<typeof ${model.name}OrderBySchema>;

    export type  ${model.name}OwnSelectFields = z.infer<typeof ${model.name}OwnSelectFieldsSchema>;

    export type  ${model.name}OwnWhere = z.infer<typeof ${model.name}OwnWhereSchema>;

    export type  ${model.name}OwnQuery = z.infer<typeof ${model.name}OwnQuerySchema>;

    export type  ${model.name}OwnQueryOne = z.infer<typeof ${model.name}OwnQueryOneSchema>;

    export type  ${model.name}Where = z.infer<typeof ${model.name}WhereSchema>;

    export type ${model.name}Include = z.infer<typeof ${model.name}IncludeSchema>;

    export type  ${model.name}QueryOne = z.infer<typeof ${model.name}QueryOneSchema>;

    export type  ${model.name}Query = z.infer<typeof ${model.name}QuerySchema>;

    export type  ${model.name}SelectFields = z.infer<typeof ${model.name}SelectFieldsSchema>;

    export type  ${model.name}Projection = z.infer<typeof ${model.name}ProjectionSchema>;

        `;

    postResult.push(allTypes);
  }

  const commonCode = [
    `
export const takeSchema = z.coerce.number().int().min(1).default(20).optional();
export const skipSchema = z.coerce.number().int().min(0).default(0).optional();
export const PaginationSchema = z.object({ 
  take: takeSchema.clone(), 
  skip: skipSchema.clone() 
}).partial()
`,

    `
export const nameSchema = z.string().min(2).max(30); 
export const descriptionSchema= z.string().max(1000); 
export const currencySchema =  z.coerce.number().positive(); 
export const positiveIntegerSchema = z.coerce.number().int().positive();
export const emailSchema = z.email();
export const dateSchema = z.iso.datetime()
export const slugSchema = z.string().regex(/^[a-z-]{2,}$/)
`,
    `
export function jsonParser<T>(value: T) {
  if (typeof value === 'string') {
    return JSON.parse(value);
  }
  return value;
};
`,
    `
export function slugTransformer(key: string) {
  return (value: any) => {
    if (value.slug == undefined && value[key] != undefined) {
      return {
        ...value,
        slug: value[key] ? slugify(value[key].toString()) : null,
      };
    }
    return value;
  };
}
  `,
  ];

  return [
    importList.join('\n'),
    commonCode.join('\n'),
    firstResult.join('\n\n'),
    secondResult.join('\n\n'),
    thirdResult.join('\n\n'),
    result.join('\n\n'),
    postResult.join('\n\n'),
  ].join('\n\n');
}
