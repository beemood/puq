import type { DMMF } from '@prisma/client/runtime/library.js';

/**
 * Check the field is included in create-operation
 * @param field
 * @returns
 */
export function isCreteField(field: DMMF.Field) {
  if (isGenerated(field)) {
    return false;
  }
  if (field.relationName) {
    return false;
  }
  return true;
}

/**
 * Check the field is allowed to update
 * @param field
 * @returns
 */
export function isUpdateField(field: DMMF.Field) {
  if (isGenerated(field)) {
    return false;
  }

  if (field.documentation?.includes('@readonly')) {
    return false;
  }

  if (field.relationName) {
    return false;
  }

  return true;
}

/**
 * Check the field is suppoed to be hashed
 * @param field
 * @returns
 */
export function isHahsed(field: DMMF.Field) {
  return field.documentation?.includes('hash');
}

/**
 * Check the field is supposed to be encripted
 * @param field
 * @returns
 */
export function isEncripted(field: DMMF.Field) {
  return field.documentation?.includes('encrypt');
}

/**
 * Check the field is generated by the database such as timestamp field (createdAt, updatedAt), generated uuid, or id
 * @param field
 * @returns
 */
export function isGenerated(field: DMMF.Field) {
  if (field.kind === 'unsupported') {
    return true;
  }

  if (field.documentation?.includes('@generated')) {
    return true;
  }

  if (field.default) {
    if ((field.default as DMMF.FieldDefault).name) {
      return true;
    }
  }

  if (field.isUpdatedAt) {
    return true;
  }

  return false;
}

/**
 * Pick the scalar where schema such as IntFilterSchema, NumberFilterSchema, DateTimeFilterSchema
 */
export function pickSchalarWhereSchema(field: DMMF.Field) {
  switch (field.kind) {
    case 'object': {
      if (field.isList) {
        return `z.object({ 
          some: ${field.type}OwnWhereSchema,
          every: ${field.type}OwnWhereSchema,
          none: ${field.type}OwnWhereSchema,
          }).partial()`;
      } else {
        return `${field.type}OwnWhereSchema`;
      }
    }
    case 'scalar': {
      switch (field.type) {
        case 'String': {
          return 'z.string().or(PZ.StringFilterSchema)';
        }
        case 'Float':
        case 'Decimal': {
          return 'z.coerce.number().or(PZ.NumberFilterSchema)';
        }
        case 'Int': {
          return 'z.coerce.number().int().or(PZ.IntegerFilterSchema)';
        }
        case 'Boolean': {
          return 'z.coerce.boolean().or(PZ.BooleanFilterSchema)';
        }
        case 'Date':
        case 'DateTime': {
          return 'z.string().or(PZ.DateTimeFilterSchema)';
        }
      }
      return '{}';
    }
    case 'enum': {
      return `${field.type}Schema`;
    }
    case 'unsupported': {
      return '';
    }
  }
}

export function generateSlugExtension(model: DMMF.Model) {
  if (model.fields.find((e) => e.name === 'slug')) {
    const sluggingFieldName = model.fields.find((e) => {
      if (!e.relationName) {
        return e.name === 'name' || e.name === 'title';
      }
      return false;
    })?.name;

    if (sluggingFieldName) {
      return `.transform(PZ.slugTransformer("${sluggingFieldName}"))`;
    }
  }

  return '';
}

export function generateZodSchemas(datamodel: DMMF.Datamodel) {
  const importList: string[] = [
    '/* eslint-disable @typescript-eslint/no-explicit-any */',
    `import * as PZ from '@puq/zod';`,
    `import { z } from 'zod';
    `,
  ];
  const firstResult: string[] = [];
  const secondResult: string[] = [];
  const thirdResult: string[] = [];

  const result: string[] = [];
  const postResult: string[] = [];

  function toZodPropertyDefinition(field: DMMF.Field) {
    const pt = [];

    switch (field.kind) {
      case 'object': {
        if (field.type === 'Json') {
          pt.push('PZ.Scalar.json()');
        }
        break;
      }
      case 'scalar': {
        switch (field.type) {
          case 'String': {
            // Specific stirng schemas  by property name
            if (field.name === 'name') {
              pt.push('PZ.Scalar.name()');
            } else if (field.name === 'description') {
              pt.push('PZ.Scalar.description()');
            } else if (field.name === 'email') {
              pt.push('PZ.Scalar.email()');
            } else if (field.name === 'slug') {
              pt.push('PZ.Scalar.slug()');
            } else {
              pt.push('PZ.Scalar.string()');
            }
            break;
          }
          case 'Boolean': {
            pt.push('PZ.Scalar.bool()');
            break;
          }
          case 'Float':
          case 'Decimal': {
            if (
              field.name === 'price' ||
              field.name === 'cost' ||
              field.name === 'total' ||
              field.name === 'subtotal' ||
              field.name === 'taxtotal'
            ) {
              pt.push('PZ.Scalar.positive()');
            } else {
              pt.push('PZ.Scalar.number()');
            }

            break;
          }

          case 'Int': {
            if (field.name === 'id' || field.name.endsWith('Id')) {
              pt.push('PZ.Scalar.id()');
            } else if (field.name === 'quantity' || field.name === 'age') {
              pt.push('PZ.Scalar.positiveInt()');
            } else {
              pt.push('PZ.Scalar.int()');
            }
            break;
          }

          case 'DateTime': {
            pt.push('PZ.Scalar.datetime()');

            break;
          }

          default: {
            throw new Error(field.type + ' is not defiend here!');
          }
        }

        break;
      }
      case 'enum': {
        pt.push(field.type + 'Schema');
        break;
      }
      case 'unsupported': {
        break;
      }
    }

    if (field.name.startsWith('slug')) {
      pt.push('optional()');
    } else if (!field.isRequired || field.hasDefaultValue) {
      pt.push('optional()');
    }

    return `${field.name}:${pt.join('.')}`;
  }

  // Create all enum schemas upfront
  for (const en of datamodel.enums) {
    const enumFields = en.values.map((e) => `"${e.name}"`).join(',');
    const enumDefinition = `export const ${en.name}Schema = z.enum([${enumFields}])`;
    firstResult.push(enumDefinition);
  }

  // Itereate through each model and create schemas
  for (const model of datamodel.models) {
    const createFields: DMMF.Field[] = [];
    const updateFields: DMMF.Field[] = [];
    const orderFields: DMMF.Field[] = [];
    const whereFields: DMMF.Field[] = [];
    const selectFields: DMMF.Field[] = [];
    const omitFields: DMMF.Field[] = [];
    const relationFields: DMMF.Field[] = [];
    const distinctFields: DMMF.Field[] = [];

    for (const field of model.fields) {
      selectFields.push(field);
      whereFields.push(field);
      if (isCreteField(field)) {
        createFields.push(field);
      }

      if (isUpdateField(field)) {
        updateFields.push(field);
      }

      if (field.relationName) {
        relationFields.push(field);
      }
      if (!field.relationName) {
        distinctFields.push(field);
        omitFields.push(field);
      }

      if (field.kind === 'scalar') {
        orderFields.push(field);
      }
    }

    const createSchemaFields = createFields
      .map(toZodPropertyDefinition)
      .join(',\n');

    const slugTransformer = generateSlugExtension(model);

    const createSchema = `
    export const ${model.name}RawCreateSchema = z.object({ 
      ${createSchemaFields}
    })

    export const ${model.name}CreateSchema = ${model.name}RawCreateSchema.clone()${slugTransformer}
    `;

    const updateSchema = `
    export const ${model.name}RawUpdateSchema = z.object({ 
        ${updateFields
          .map(toZodPropertyDefinition)
          .map((e) => e + '.optional()')
          .join(',\n')}
    });

    export const ${model.name}UpdateSchema = ${
      model.name
    }RawUpdateSchema.clone()${slugTransformer}
    `;

    const distinctFieldsString = distinctFields
      .map((e) => `"${e.name}"`)
      .join(',');
    const distinctFieldsSchema = `
    export const ${model.name}DistinctFieldsSchema = z.enum([ ${distinctFieldsString} ]).array()
    `;

    const orderBySchemaFields = orderFields
      .map((e) => `${e.name}: PZ.OrderDirectionSchema`)
      .join(',\n');
    const orderBySchema = `
    export const ${model.name}OrderBySchema = z.object({
        ${orderBySchemaFields}
    })
        .partial()
        .refine(value=> typeof value ==='object' && Object.keys(value).length === 1)
        .array()

    export const ${model.name}OrderBySchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}OrderBySchema);
    `;

    const ownSelectFieldsFields = selectFields
      .map((e) => `${e.name}: PZ.Scalar.bool()`)
      .join(',\n');

    const ownSelectFieldsSchema = `
      export const ${model.name}OwnSelectFieldsSchema = z.object({ 
          ${ownSelectFieldsFields}
      }).partial()

      export const ${model.name}OwnSelectFieldsSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}OwnSelectFieldsSchema);
      
      `;

    const ownWhereSchemaFields = whereFields
      .filter((e) => !e.relationName)
      .map((e) => `${e.name}:${pickSchalarWhereSchema(e)}`)
      .join(',\n');
    const ownWhereSchema = `
    export const ${model.name}OwnWhereSchema = z.object({ 
      ${ownWhereSchemaFields}
    }).partial()

    export const ${model.name}OwnWhereSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}OwnWhereSchema);
    `;

    const ownQuerySchema = `
    export const ${model.name}OwnQuerySchema = z.object({ 
      where: ${model.name}OwnWhereSchemaJson, 
      distinct: ${model.name}DistinctFieldsSchema 
    }).partial()
    `;

    const ownQueryOneSchema = `
    export const ${model.name}OwnQueryOneSchema = z.object({ 
        where:${model.name}OwnWhereSchemaJson,
        distinct: ${model.name}DistinctFieldsSchema
    }).partial()
    `;

    const whereSchemaFields = whereFields
      .map((e) => `${e.name}: ${pickSchalarWhereSchema(e)}`)
      .join(',\n');
    const whereSchema = `
    export const ${model.name}WhereSchema = z.object({ 
        ${whereSchemaFields}
    }).partial()

    export const ${model.name}WhereSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}WhereSchema);
    `;

    const ownIncludeSchemaFields = relationFields
      .map((e) => `${e.name}: PZ.Scalar.bool()`)
      .join(',\n');
    const ownIncludeSchema = `
    export const ${model.name}OwnIncludeSchema = z.object({ 
      ${ownIncludeSchemaFields}
    }).partial()

    export const ${model.name}OwnIncludeSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}OwnIncludeSchema);
    `;

    const includeSchemaFields = relationFields
      .map((e) => {
        if (e.isList) {
          return `${e.name}: PZ.Scalar.bool().or(${e.type}OwnQuerySchema)`;
        } else {
          return `${e.name}: PZ.Scalar.bool().or(${e.type}OwnQueryOneSchema)`;
        }
      })
      .join(',\n');
    const includeSchema = `
    export const ${model.name}IncludeSchema = z.object({ 
      ${includeSchemaFields}
    }).partial()

    export const ${model.name}IncludeSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}IncludeSchema);
    `;

    const queryOneSchema = `
    export const ${model.name}QueryOneSchema = z.object({ 
      where: ${model.name}WhereSchemaJson,
      distinct: ${model.name}DistinctFieldsSchema
    }).partial()
    `;

    const querySchema = `
    export const ${model.name}QuerySchema = z.object({ 
      ...PaginationSchema.shape,
      where: ${model.name}WhereSchemaJson, 
      distinct: ${model.name}DistinctFieldsSchema, 
      orderBy: ${model.name}OrderBySchemaJson,
    }).partial()
    `;

    const omitFieldSchemaFields = omitFields
      .map((e) => `${e.name}: PZ.Scalar.bool()`)
      .join(',\n');

    const omitFieldsSchema = `
     export const ${model.name}OmitFieldsSchema = z.object({ 
          ${omitFieldSchemaFields}
     })
          .partial()
          .refine(
           value=>![${omitFields.map(
             (e) => `"${e.name}"`
           )}].every(e=>Object.hasOwn(value,e)),
           {message:"Cannot omit all fields", path:["omit"] })
    
     export const ${
       model.name
     }OmitFieldsSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${
      model.name
    }OmitFieldsSchema);
      `;

    const selectFieldSchemaFields = selectFields
      .map((e) => {
        if (e.relationName) {
          if (e.isList) {
            return `${e.name}: PZ.Scalar.bool().or(${e.type}OwnQuerySchema)`;
          } else {
            return `${e.name}: PZ.Scalar.bool().or(${e.type}OwnQueryOneSchema)`;
          }
        }
        return `${e.name}: PZ.Scalar.bool()`;
      })
      .join(',\n');

    const selectFieldsSchema = `
    export const ${model.name}SelectFieldsSchema = z.object({ 
          ${selectFieldSchemaFields}
     }).partial()
 
    export const ${model.name}SelectFieldsSchemaJson = z.preprocess(PZ.jsonPreprocessor, ${model.name}SelectFieldsSchema);
   `;

    const projectionSchema = `
     export const ${model.name}ProjectionSchema = z.union([
        z.object({ omit: ${model.name}OmitFieldsSchemaJson }),
        z.object({ select: ${model.name}SelectFieldsSchemaJson }),
        z.object({ include: ${model.name}IncludeSchemaJson }),
        z.object({})
      ])
     `;

    firstResult.push(ownSelectFieldsSchema);
    firstResult.push(distinctFieldsSchema);
    secondResult.push(ownWhereSchema);
    thirdResult.push(ownIncludeSchema);
    thirdResult.push(ownQueryOneSchema);
    thirdResult.push(ownQuerySchema);

    result.push(createSchema);
    result.push(updateSchema);
    result.push(orderBySchema);
    result.push(whereSchema);
    result.push(selectFieldsSchema);
    result.push(omitFieldsSchema);
    result.push(includeSchema);
    result.push(projectionSchema);
    postResult.push(queryOneSchema);
    postResult.push(querySchema);

    const allTypes = `
    export type  ${model.name}Create = z.infer<typeof ${model.name}RawCreateSchema>;

    export type  ${model.name}Update = z.infer<typeof ${model.name}RawUpdateSchema>;

    export type  ${model.name}OrderBy = z.infer<typeof ${model.name}OrderBySchema>;

    export type  ${model.name}OwnSelectFields = z.infer<typeof ${model.name}OwnSelectFieldsSchema>;

    export type  ${model.name}OwnWhere = z.infer<typeof ${model.name}OwnWhereSchema>;

    export type  ${model.name}OwnQuery = z.infer<typeof ${model.name}OwnQuerySchema>;

    export type  ${model.name}OwnQueryOne = z.infer<typeof ${model.name}OwnQueryOneSchema>;

    export type  ${model.name}Where = z.infer<typeof ${model.name}WhereSchema>;

    export type ${model.name}Include = z.infer<typeof ${model.name}IncludeSchema>;

    export type  ${model.name}QueryOne = z.infer<typeof ${model.name}QueryOneSchema>;

    export type  ${model.name}Query = z.infer<typeof ${model.name}QuerySchema>;

    export type  ${model.name}OmitFields = z.infer<typeof ${model.name}OmitFieldsSchema>;

    export type  ${model.name}SelectFields = z.infer<typeof ${model.name}SelectFieldsSchema>;

    export type  ${model.name}Projection = z.infer<typeof ${model.name}ProjectionSchema>;

        `;

    postResult.push(allTypes);
  }

  const commonCode = [
    `
export const PaginationSchema = z.object({ 
  take: PZ.Scalar.take(),
  skip: PZ.Scalar.skip()
}).partial()
`,
  ];

  return [
    importList.join('\n'),
    commonCode.join('\n'),
    firstResult.join('\n\n'),
    secondResult.join('\n\n'),
    thirdResult.join('\n\n'),
    result.join('\n\n'),
    postResult.join('\n\n'),
  ].join('\n\n');
}
